# Hash

---

## 면접 질문

1. 해시 테이블에서 사용하는 해시의 개념은 무엇이며, 이러한 자료 구조가 배열, 리스트와 같은 다른 자료 구조와 비교하여 어떤 장점을 가지나요? 해시 테이블이 실생활에서 어떻게 사용될 수 있는지 예를 들어 설명하세요.
    - 주요 키워드 :
        1. 해시함수 : 임의의 키값을 인덱스로 바꿔주는 함수 
        2. 해시테이블 : 해시 함수를 이용해서 주어진 값을 해시화하여, 그 해시값을 인덱스로 삼아 값(value)를 저장하는 테이블.
        
    - 해시 테이블의 주요 장점은 정보를 접근하는데 드는 시간이 거의 O(1)라는 것이다. 다른 자료구조와 비교했을 때의 가장 큰 장점은 그러면서 원하는 값을 찾을 수 있다는 것이다. 빠른 접근, 원하는 값의 저장 혹은 반환.
    
    - 실생활에서는 파이썬의 해시맵의 정의인 dictionary를 생각해보면 좋을 거 같다. 사전이 key,value 구조를 아주 잘 나타내고 있다. 해시 충돌은 key_1, key_2 이렇게 바꿔서 linkedlist나 priorityqueue(사용빈도)를 체이닝으로 이용하고 있는데, 여기서 priorityQueue를 쓴다면 중요도에 따라 우선순위를 메길 수 있다.
    
2. 해시 함수에서 "완벽한 해시 함수"란 무엇을 의미하나요? 현실적인 상황에서 완벽한 해시 함수를 구현하는 것이 어려운 이유는 무엇인가요? 해시 함수의 설계 시 고려해야 할 주요 요소를 설명하세요.
    - 완벽한 해시충돌이 일어나지 않는 해시함수
        
        고려해야 할 것 : 해시테이블 사이즈, 해시함수 및 설계 
        
3. 해시 충돌이 발생하는 근본적인 이유는 무엇인가요? 충돌이 발생할 가능성을 수학적으로 설명하고, 해시 테이블이 충돌을 허용할 수밖에 없는 구조적인 이유를 설명하세요.

수학적으로 생각하면 PigeonHall Principle 생각해보면 좋다. 키가 n+1개면, n개는 선형 탐색으로 전부 중첩없이 해시 테이블에 키를 저장했는데 n+1번째값은 충돌이 생길 수밖에 없다. 

그러므로, 키가 많아지면 어쨌든 충돌할 수 밖에 없다. 해시테이블의 사이즈가 유한하기 때문에. 이는 체이닝으로 막으나, 오픈 어드레싱으로 막으나 마찬가지다. 단지, 효율적인 방식을 찾아갈 뿐이다. 

1. 해시 충돌을 해결하는 방법 중 "체이닝"과 "개방 주소법"을 비교하여 설명하세요. 이 두 방법이 사용하는 메모리와 시간 복잡도 관점에서의 차이를 기술하고, 각각의 방법이 실제 응용에서 적합한 시나리오는 무엇인가요?
    
    
    chaining, open addressing은 모두 해시값 충돌(collision) 시에 적용하는 기법입니다. 충돌이란 원래의 해시값이 다른 키의 해시값과 충돌하는 문제를 말한다.
    
    - chaining : 체이닝을 쓰는 가장 중요한 이유는 크게 테이블 사이즈를 변경할 수 없는 경우, 충돌이 빈번하거나 데이터 삭제가 자주 발생할 때 사용한다. 오픈 어드레스를 쓰는 경우에는 이 경우 현재 기록된 값을 지워야 하는데 없을 수도 있기 때문이다. 그리고 충돌이 빈번한 경우 체이닝을 쓰는 경우가 시간을 쓰더라도 확실히 값을 구할 수 있기 때문이다.
    - open-addressing : 테이블 사이즈에 비해 데이터 사이즈가 작을 때 혹은 재해싱의 필요가 없을 때.
        
        하지만 오픈 어드레싱만 사용하는 경우에는 리사이징 시 재해싱으로 인하여 효율이 안 좋을 수도 있다.
        
2. 체이닝 기법의 성능을 분석하세요. 체이닝 방식에서 성능 저하를 유발할 수 있는 문제는 무엇이 있으며, 이를해결하기 위한 최적화 방법이나 대안은 어떤 것들이 있을까요?
    
    
    - 해시 테이블 사이즈가 작아서 충돌 자체를 피할 수가 없기 때문에 연결리스트의 효율성이 떨어지는 경우
    - 뿐만 아니라 어떤 해시값 하나 두개가 충돌이 너무 잦아서 특정 해시값의 효율이 너무 떨어지는 경우
    
    방법 1 : LinkedList가 아니라 자료형에 맞는 이진탐색트리를 써서 탐색 시간을 n에서 log(n)으로 줄인다. 
    
    방법 2 : 방법 1이 불가능하고, 메모리를 신경 쓰지 않는다면, 해시 안에 해시를 쓰는 방식으로 할 수도 있다.
    
    C.F. 문자열에 경우 존재하는 경우를 찾는 건 LinkedList 대신 Trie를 써도 좋을 거 같다.  
    

1. 개방 주소법에서 사용되는 다양한 탐색 전략(예: 선형 탐사, 이차 탐사, 이중 해싱) 간의 차이를 설명하고, 각 전략의 장단점을 분석하세요. 어떤 상황에서 특정 전략을 사용하는 것이 더 적합한지 논의하세요.
    
    
    - 선형 탐사(Linear probing) : 충돌이 생겼을 때 순차탐색을 통해 빈 해시값을 찾는다.
        - h(k) : hash function, val1 : given value, $h(val1),$ $h(val1) + 1, h(val1) + 2, …$
    - 이차 탐사(Second probing) : 충돌이 생겼을 때 제곱을 이용해서 빈 해시값을 찾는다.
        - h(k) : hash function, val1 : given value, $h(val1), h(val1) + 1^2, h(val1) + 2^2,\ ...$
    - 이중 해싱(double hasing) : 충돌이 생겼을 때, 두가지 해시함수를 조합해서 찾는다.
        - h(k), g(k) : hash function, val1 : given value. $h(val1) + g(val1)$,  $h(val1) + 2g(val1)$
    
    선형 탐사, 이차 탐사, 이중 해싱 전부 값을 구해준 다음에 mod( hash table size) 해줘야 한다. 
    
2. 해시 테이블의 평균적인 시간 복잡도가 O(1)로 유지되기 위한 조건을 설명하고, 이 조건이 무너질 때 발생할 수 있는 최악의 시간 복잡도 O(n)이 발생하는 구체적인 시나리오를 제시하세요. 또한 이러한 상황을 방지하기 위해 사용할 수 있는 기법들은 무엇인가요?

- 조건 : 해시테이블의 사이즈가 키 값보다 더 커서 충분히 선형 탐색으로 모든 키를 완벽하게 해시화 할 수 있을 때
- 이 조건이 깨지는 경우는 특정 인덱스의 중복이 많이 생겨서, 그 인덱스인 해시값에서 연결리스트를 탐색하는데 O(n)이 발생할 수도 있다.
- 적절한 체이닝과 오픈 어드레싱을 섞어서 사용해서 테이블의 부하율과 클러스터링을 적절히 줄여서(오픈 어드레싱 세팅에 따라) 효율을 높여야 한다.

## 실전 문제

---

**문제 1**

학생들의 점수를 저장하는 딕셔너리가 있습니다. 이 딕셔너리에서 특정 학생의 이름을 입력받아 그 학생의 점수를 출력하는 함수를 작성하세요.

입출력 예:

- 입력: "홍길동"
- 출력: 85

입출력 예에 대한 설명: 입력으로 주어진 학생의 이름 "홍길동"에 해당하는 점수가 딕셔너리에서 85로 저장되어 있으므로 85를 출력합니다.

제약사항:

- 학생의 이름은 딕셔너리에 항상 존재한다고 가정합니다.
- 딕셔너리는 { "홍길동": 85, "이순신": 90, "장영실": 78 }와 같은 구조입니다.

```python
def hisorHerScore(scores:dict[str,int], name:str)->int:
	return scores[name]

print(hisorHerScore({ "홍길동": 85, "이순신": 90, "장영실": 78 },"홍길동"))
```

**문제 2**

주어진 딕셔너리에서 값이 특정 값보다 큰 키만을 추출하여 새로운 딕셔너리를 반환하는 함수를 작성하세요.

입출력 예:

- 입력: { "a": 10, "b": 20, "c": 5 }, 기준 값: 10
- 출력: { "b": 20 }

입출력 예에 대한 설명: 딕셔너리에서 값이 10보다 큰 키는 "b"뿐이므로, 새로운 딕셔너리는 { "b": 20 }입니다.

제약사항:

- 입력 딕셔너리의 값은 모두 정수입니다.
- 기준 값은 양수입니다.

```python
# 입력: { "a": 10, "b": 20, "c": 5 }, 기준 값: 10
a = { "a": 10, "b": 20, "c": 5 }
pivot = 10 
b = dict()
for key, value in a.items():
    if value > pivot:
        b.update({key:value})

print(b)
```

**문제 3**

두 개의 딕셔너리를 입력받아, 두 딕셔너리의 키와 값을 모두 합친 새로운 딕셔너리를 반환하는 함수를 작성하세요. 만약 같은 키가 존재할 경우, 값은 더한 값을 저장하세요.

입출력 예:

- 입력: { "a": 1, "b": 2 }, { "b": 3, "c": 4 }
- 출력: { "a": 1, "b": 5, "c": 4 }

입출력 예에 대한 설명: 두 딕셔너리에서 중복된 키 "b"의 값은 2와 3이므로 더한 값 5가 저장됩니다.

제약사항:

- 딕셔너리의 값은 모두 정수입니다.
- 중복된 키에 대한 처리만 고려하면 됩니다.

```python
INF = float('inf')
a, b = { "a": 1, "b": 2 }, { "b": 3, "c": 4 }

def nerge_dicts(a:dict[str:int],b:dict[str:int])->dict[str:int]:
	for key, value in a.items():
	    if(b.get(key,INF)==INF):
	        b.update({key:value})
	    else:
	        b[key]+= value
	
	print({k: v for k, v in sorted(b.items(), key=lambda x:x[0])})
```

**문제 4**

문자열로 이루어진 리스트를 입력받아, 각 문자열의 길이를 값으로 가지는 딕셔너리를 반환하는 함수를 작성하세요.

입출력 예:

- 입력: ["apple", "banana", "pear"]
- 출력: { "apple": 5, "banana": 6, "pear": 4 }

입출력 예에 대한 설명: 입력 리스트의 각 문자열의 길이를 딕셔너리의 값으로 변환한 결과입니다.

제약사항:

- 리스트 내 문자열의 길이는 1 이상입니다.
- 문자열은 중복되지 않습니다.

```python
def dictToLength(a:list[str])->dict[str:int]:
    b:dict[str:int] = dict()

    for string in a:
        b[string] = len(string)
    
    return b

print(dictToLength(["apple", "banana", "pear"]))
```

**문제 5**

학생들의 점수 딕셔너리에서 모든 학생의 평균 점수를 반환하는 함수를 작성하세요.

입출력 예:

- 입력: { "홍길동": 85, "이순신": 90, "장영실": 78 }
- 출력: 84.33

입출력 예에 대한 설명: 모든 학생의 점수의 합이 253이며, 학생 수 3으로 나누었을 때 84.33이 됩니다. 소수점 둘째 자리까지 출력합니다.

제약사항:

- 딕셔너리에는 최소 1명의 학생이 있습니다.
- 점수는 0 이상 100 이하의 정수입니다.

```python
def mapToAverage(students:dict[str:int])->float:

    return sum(students.values())/len(students)

a = { "홍길동": 85, "이순신": 90, "장영실": 78 }
print(f"{  mapToAverage(a)  :0.2f}")
```

---

### **❗이 스터디는 코딩 테스트 합격자 되기: 파이썬 편의 저자인 박경록님과 함께 합니다.**

---
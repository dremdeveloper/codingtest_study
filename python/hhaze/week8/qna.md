
## 면접 질문
1. 해시 테이블에서 사용하는 해시의 개념은 무엇이며, 이러한 자료 구조가 배열, 리스트와 같은 다른 자료 구조와 비교하여 어떤 장점을 가지나요? 해시 테이블이 실생활에서 어떻게 사용될 수 있는지 예를 들어 설명하세요.
- 해시의 개념
    - 해시 함수를 사용해서 변환한 값을 인덱스로 삼아 키와 값을 저장하는 자료구조
- 다른 자료 구조와 비교할 때 장점
    - 탐색을 할 필요 없이 바로 데이터를 찾아낼 수 있는 점 -> 시간 복잡도 O(1)
- 실생활에서 사용되는 예
    - 비밀번호 관리
        - 해시 함수를 활용해 해싱한 비밀번호를 저장하고 비밀번호가 맞는지 확인할 때도 사용자가 입력한 비밀번호를 해싱해 확인
    - 데이터베이스 인덱싱
        - 데이터베이스에 저장된 데이터를 효율적으로 검색할 때 해시를 활용
    - 블록체인
        - 각 블록은 이전 블록의 해시값을 포함하고 있으며 이를 통해 데이터 무결성 확인

2. 해시 함수에서 "완벽한 해시 함수"란 무엇을 의미하나요? 현실적인 상황에서 완벽한 해시 함수를 구현하는 것이 어려운 이유는 무엇인가요? 해시 함수의 설계 시 고려해야 할 주요 요소를 설명하세요.
- 완벽한 해시 함수란
    - 충돌이 없는 것
- 현실적인 상황에서 완벽한 해시 함수를 구현하는 것이 어려운 이유
    - 현실적인 상황에서 모든 키에 대해 해시 함수의 결괏값을 고유하게 생성하는 것은 거의 불가능
- 해시 함수의 설계 시 고려해야 할 주요 요소
    - 해시 함수가 변환한 값은 인덱스로 활용해야 하므로 해시 테이블의 크기를 넘으면 안 된다는 점
    - 해시 함수가 변환한 값의 충돌은 최대한 적게 발생해야 한다는 점

3. 해시 충돌이 발생하는 근본적인 이유는 무엇인가요? 충돌이 발생할 가능성을 수학적으로 설명하고, 해시 테이블이 충돌을 허용할 수밖에 없는 구조적인 이유를 설명하세요.
- 해시 테이블이 충돌을 허용할 수밖에 없는 구조적인 이유
    - 메모리의 크기가 유한하기에 모든 키에 대해 해시 함수의 결괏값을 고유하게 생성하는 것은 불가능하기 때문

4. 해시 충돌을 해결하는 방법 중 "체이닝"과 "개방 주소법"을 비교하여 설명하세요. 이 두 방법이 사용하는 메모리와 시간 복잡도 관점에서의 차이를 기술하고, 각각의 방법이 실제 응용에서 적합한 시나리오는 무엇인가요?
- 체이닝
    - 충돌이 발생하면 해당 버킷에 링크드리스트로 같은 해시값을 가지는 데이터를 연결
    - 추가 메모리 필요
    - 시간 복잡도는 최악의 경우 O(N)
        - 링크드리스트로 연결한 값을 찾으려면 링크드리스트의 맨 앞 데이터부터 검색해야 하기 때문
    - 동적인 데이터 구조에 적합
- 개방 주소법
    - 충돌이 발생하면 빈 버킷을 찾아 충돌값을 삽입
    - 추가 메모리 불필요
    - 시간 복잡도는 최악의 경우 O(N)
        - 모든 키가 충돌하면 빈 버킷을 찾아 이동해야 하기 때문?
    - 메모리 크기가 제한된 환경에 적합

5. 체이닝 기법의 성능을 분석하세요. 체이닝 방식에서 성능 저하를 유발할 수 있는 문제는 무엇이 있으며, 이를 해결하기 위한 최적화 방법이나 대안은 어떤 것들이 있을까요?
- 성능 저하를 유발할 수 있는 문제
    - 충돌이 발생하여 특정 버킷에 데이터가 집중되면 링크드리스트로 연결한 값을 찾기 위해 링크드리스트의 맨 앞 데이터부터 검색해야 하는 점
- 성능 저하를 해결하기 위한 최적화 방법이나 대안
    - 충돌이 발생할 때 링크드리스트에 데이터가 연결되므로, 최대한 충돌을 막을 수 있는 해시 함수를 사용

6. 개방 주소법에서 사용되는 다양한 탐색 전략(예: 선형 탐사, 이차 탐사, 이중 해싱) 간의 차이를 설명하고, 각 전략의 장단점을 분석하세요. 어떤 상황에서 특정 전략을 사용하는 것이 더 적합한지 논의하세요.
- 선형 탐사
    - 충돌이 발생하면 다른 빈 버킷을 찾을 때까지 일정한 간격(보통 1)으로 이동
    - 장점: 구현이 간단
    - 단점: 해시 충돌이 발생한 값끼리 모이는 영역이 생기는데 (클러스터 형성) 이런 군집이 생기면 해시값은 겹칠 확률이 더 올라간다는 점
- 이차 탐사
    - 충돌이 발생하면 다른 빈 버킷을 찾을 때까지 제곱수 간격으로 이동
    - 장점: 선형 탐사의 군집 문제를 방지
    - 단점: ?
- 이중 해싱
    - 해시 함수를 2개를 사용하며 두 번째 해시 함수의 역할은 첫 번째 해시 함수로 충돌이 발생하면 해당 위치를 기준으로 어떻게 위치를 정할지 결정하는 역할
    - 장점: 클러스터 형성 최대한 방지 가능
    - 단점: 두 개의 해시 함수를 사용하기 위한 추가 연산
   
7. 해시 테이블의 평균적인 시간 복잡도가 O(1)로 유지되기 위한 조건을 설명하고, 이 조건이 무너질 때 발생할 수 있는 최악의 시간 복잡도 O(n)이 발생하는 구체적인 시나리오를 제시하세요. 또한 이러한 상황을 방지하기 위해 사용할 수 있는 기법들은 무엇인가요?
- 해시 테이블의 평균적인 시간 복잡도가 O(1)로 유지되기 위한 조건 
    - 충돌이 없는 해시 함수 사용
- 최악의 시간 복잡도 O(n)이 발생하는 구체적인 시나리오
    - 모든 키에 대해서 해시 함수의 결괏값이 동일해서 하나의 버킷에 모든 데이터가 저장되는 경우, 체이닝 방식을 사용한다고 할 때 하나의 긴 링크드리스트가 만들어지고 탐색 시 O(n) 시간 복잡도 발생
- 이러한 상황을 방지하기 위해 사용할 수 있는 기법들
    - 체이닝
    - 개방 주소법
        - 선형 탐사
        - 이차 탐사
        - 이중 해싱


## 실전 문제

### 문제 1
학생들의 점수를 저장하는 딕셔너리가 있습니다. 이 딕셔너리에서 특정 학생의 이름을 입력받아 그 학생의 점수를 출력하는 함수를 작성하세요.

입출력 예:
- 입력: "홍길동"
- 출력: 85

입출력 예에 대한 설명: 입력으로 주어진 학생의 이름 "홍길동"에 해당하는 점수가 딕셔너리에서 85로 저장되어 있으므로 85를 출력합니다.

제약사항:
- 학생의 이름은 딕셔너리에 항상 존재한다고 가정합니다.
- 딕셔너리는 { "홍길동": 85, "이순신": 90, "장영실": 78 }와 같은 구조입니다.

```python
def solution(s):
    dic = { "홍길동": 85, "이순신": 90, "장영실": 78 }

    return dic[s]
```

### 문제 2
주어진 딕셔너리에서 값이 특정 값보다 큰 키만을 추출하여 새로운 딕셔너리를 반환하는 함수를 작성하세요.

입출력 예:
- 입력: { "a": 10, "b": 20, "c": 5 }, 기준 값: 10
- 출력: { "b": 20 }

입출력 예에 대한 설명: 딕셔너리에서 값이 10보다 큰 키는 "b"뿐이므로, 새로운 딕셔너리는 { "b": 20 }입니다.

제약사항:
- 입력 딕셔너리의 값은 모두 정수입니다.
- 기준 값은 양수입니다.

```python
def solution(dic, value):
    result = {}

    for k, v in dic.items():
        if v > value:
            result[k] = v
    
    return result
```

### 문제 3
두 개의 딕셔너리를 입력받아, 두 딕셔너리의 키와 값을 모두 합친 새로운 딕셔너리를 반환하는 함수를 작성하세요. 만약 같은 키가 존재할 경우, 값은 더한 값을 저장하세요.

입출력 예:
- 입력: { "a": 1, "b": 2 }, { "b": 3, "c": 4 }
- 출력: { "a": 1, "b": 5, "c": 4 }

입출력 예에 대한 설명: 두 딕셔너리에서 중복된 키 "b"의 값은 2와 3이므로 더한 값 5가 저장됩니다.

제약사항:
- 딕셔너리의 값은 모두 정수입니다.
- 중복된 키에 대한 처리만 고려하면 됩니다.

```python
def solution(dic1, dic2):
    result = dic1

    for k, v in dic2.items():
        if k in result:
            result[k] += v
        else:
            result[k] = v

    return result
```

### 문제 4
문자열로 이루어진 리스트를 입력받아, 각 문자열의 길이를 값으로 가지는 딕셔너리를 반환하는 함수를 작성하세요.

입출력 예:
- 입력: ["apple", "banana", "pear"]
- 출력: { "apple": 5, "banana": 6, "pear": 4 }

입출력 예에 대한 설명: 입력 리스트의 각 문자열의 길이를 딕셔너리의 값으로 변환한 결과입니다.

제약사항:
- 리스트 내 문자열의 길이는 1 이상입니다.
- 문자열은 중복되지 않습니다.

```python
def solution(arr):
    result = {}

    for i in arr:
        result[i] = len(i)
    
    return result
```

### 문제 5
학생들의 점수 딕셔너리에서 모든 학생의 평균 점수를 반환하는 함수를 작성하세요.

입출력 예:
- 입력: { "홍길동": 85, "이순신": 90, "장영실": 78 }
- 출력: 84.33

입출력 예에 대한 설명: 모든 학생의 점수의 합이 253이며, 학생 수 3으로 나누었을 때 84.33이 됩니다. 소수점 둘째 자리까지 출력합니다.

제약사항:
- 딕셔너리에는 최소 1명의 학생이 있습니다.
- 점수는 0 이상 100 이하의 정수입니다.

```python
def solution(dic):
    value_sum = sum(dic.values())
    value_len = len(dic)
    result = round(value_sum / value_len, 2)

    return result
```
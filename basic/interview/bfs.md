
## 목차
1. 가중치가 없는 그래프에서 BFS와 최단 경로
2. 우선순위 큐 성능 최적화
3. BFS와 DFS의 차이점
4. BFS 큐 vs. 우선순위 큐
5. 실전 문제

## 면접 문제
1. 가중치가 없는 그래프에서 BFS를 사용하면 최단 경로를 찾을 수 있습니다. 그러나 가중치가 있는 그래프에서는 BFS가 최단 경로를 보장하지 못하는 이유를 설명하고, 이러한 상황에서 최단 경로를 찾기 위한 대안을 제시하세요.
2. 삽입과 삭제가 빈번하게 발생하는 동적 데이터 세트에서 우선순위 큐의 성능을 최적화하는 방법을 설명하세요. 삽입과 삭제 연산의 시간 복잡도를 어떻게 개선할 수 있을지 제시하세요.
3. BFS와 DFS의 차이점을 그래프 탐색 관점에서 설명하고, BFS가 DFS보다 더 적합한 문제 유형을 설명하세요. 또한, 두 탐색 알고리즘의 공간 복잡도 및 시간 복잡도 차이에 대해 구체적으로 제시하세요.
4. 일반적인 BFS에서 사용하는 큐와 다익스트라 알고리즘 등에서 사용하는 우선순위 큐의 차이점에 대해 설명하세요. 이 두 자료 구조가 탐색 과정에 미치는 영향을 구체적으로 제시하세요.


# 실전 문제


## 문제 1: 큐를 이용한 작업 순서 처리

### 설명
여러 개의 작업이 주어졌을 때, 각 작업은 큐에 들어간 순서대로 처리되는 것이 원칙입니다. 하지만 각 작업에는 우선순위가 있으며, 우선순위가 높은 작업을 먼저 처리해야 할 경우도 있습니다. 
우선순위가 높은 작업이 있을 때에는 먼저 처리되고, 그렇지 않으면 큐에 들어온 순서대로 작업이 처리됩니다.

즉, 큐에 있는 작업들 중 현재 가장 높은 우선순위를 가진 작업이 있을 경우 해당 작업이 먼저 처리되며, 우선순위가 동일한 작업들끼리는 큐에 들어온 순서대로 처리됩니다.

이 문제에서 특정 작업이 몇 번째로 처리되는지 알고 싶습니다.

### 입력
- 첫 번째 줄에 작업의 수 n이 주어집니다. (1 ≤ n ≤ 1000)
- 두 번째 줄에 각 작업의 우선순위가 공백으로 구분된 n개의 정수로 주어집니다. (1 ≤ 우선순위 ≤ 9)
- 세 번째 줄에 우리가 처리하고자 하는 특정 작업의 위치가 주어집니다. (0 ≤ 작업 위치 < n)

### 출력
- 특정 작업이 몇 번째로 처리되는지 출력하세요.

### 입출력 예시

#### 입력
```
6
1 1 9 1 1 1
2
```
#### 출력
```
1
```

### 예시 설명
주어진 작업의 우선순위 배열은 `[1, 1, 9, 1, 1, 1]`입니다. 2번 위치에 있는 작업의 우선순위는 9이며, 큐에서 가장 높은 우선순위입니다. 따라서 해당 작업은 가장 먼저 처리됩니다.

### 제한사항
- 모든 작업은 한 번만 처리됩니다.
- 처리 도중 동일한 우선순위가 여러 개 있을 경우, 먼저 큐에 들어온 작업이 우선됩니다.
- 주어진 작업의 우선순위는 1 이상 9 이하의 정수로만 구성됩니다.


---

## 문제 2: 애너그램 판별
### 설명
두 개의 문자열이 주어졌을 때, 두 문자열이 애너그램 관계인지 확인하는 프로그램을 작성하세요. 애너그램은 두 문자열의 문자 구성이 동일하지만 순서가 다른 관계를 말합니다.

### 입력
- 첫 번째 줄에 첫 번째 문자열이 주어집니다.
- 두 번째 줄에 두 번째 문자열이 주어집니다.

### 출력
- 두 문자열이 애너그램 관계라면 true, 아니라면 false를 출력하세요.

### 입출력 예시
#### 입력
```
listen
silent
```

#### 출력
```
true
```

#### 설명
`listen`과 `silent`는 애너그램 관계입니다.

### 제한사항
- 문자열의 길이는 1 이상 100 이하입니다.
- 문자열은 소문자 알파벳으로만 구성됩니다.

---


## 문제 3: BFS를 이용한 이진 트리 값 찾기

### 설명
이진 트리에서 특정 값을 찾고, 그 값이 존재하는지 확인하는 프로그램을 작성하세요. 이 문제에서는 BFS(너비 우선 탐색) 알고리즘을 이용하여 트리를 탐색하게 됩니다.

BFS는 루트 노드부터 시작하여 같은 레벨의 노드를 차례대로 방문하는 방식입니다. 주어진 트리에서 레벨 순서로 탐색하면서, 찾고자 하는 값이 트리 안에 존재하는지 여부를 확인하는 것이 목표입니다.

트리는 주어진 노드 값을 바탕으로 구성되며, null은 해당 위치에 노드가 없음을 나타냅니다. BFS를 통해 트리를 순차적으로 탐색하여, 해당 값을 찾는지 확인합니다.

### 입력
- 첫 번째 줄에는 이진 트리의 노드 값들이 레벨 순서로 공백으로 구분되어 주어집니다. `null` 값은 해당 위치에 노드가 없음을 의미하며 "null"로 표현됩니다.
- 두 번째 줄에는 찾고자 하는 값이 주어집니다. 이 값은 트리 내에서 탐색될 값입니다.

### 출력
- 찾고자 하는 값이 트리 안에 존재하면 `true`를 출력하고, 존재하지 않으면 `false`를 출력하세요.


### 입출력 예시

#### 입력
```
3 9 20 null null 15 7
15
```
#### 출력
```
true
```

### 예시 설명
주어진 트리는 다음과 같습니다:
```
       3
     /   \
    9     20
         /  \
        15   7
```
BFS 탐색 순서는 3 -> 9 -> 20 -> 15 -> 7 순으로 이루어지며, 값 15를 찾았을 때 탐색을 종료하고 `true`를 반환합니다.

#### 입력 2
```
3 9 20 null null 15 7
8
```
#### 출력
```
false
```

### 제한사항
- 트리의 노드 수는 1 이상 10^4 이하입니다.
- 각 노드의 값은 -10^5 이상 10^5 이하의 정수입니다.
- 트리에서 "null"은 해당 위치에 노드가 없음을 나타냅니다.
___

## 문제 4: BFS를 이용한 최단 경로 찾기
### 설명
주어진 그래프에서 너비 우선 탐색(BFS)을 사용하여, 시작 노드로부터 다른 모든 노드까지의 최단 경로를 구하는 프로그램을 작성하세요. 그래프는 무방향이며, 각 간선의 가중치는 동일합니다. 또한, 각 노드는 1에서 n까지의 번호를 가지며, 여러 개의 최단 경로가 존재할 경우 첫 번째로 발견된 경로를 출력합니다.

### 입력
- 첫 번째 줄에 노드의 수 n(1 ≤ n ≤ 1000)과 간선의 수 m(1 ≤ m ≤ 10000)이 주어집니다.
- 그다음 m개의 줄에는 두 개의 정수 u, v(1 ≤ u, v ≤ n)가 주어지며, 이는 u와 v 사이에 간선이 있다는 것을 의미합니다.
- 마지막 줄에 시작 노드가 주어집니다.

### 출력
- 각 노드로 가는 최단 경로의 길이를 오름차순으로 출력하세요. 만약 도달할 수 없는 노드가 있다면 "INF"를 출력하세요.

### 입출력 예시
#### 입력
```
6 7
1 2
1 3
2 4
3 4
3 5
4 6
5 6
1
```
#### 출력
```
0 1 1 2 2 3
```

#### 설명
시작 노드 1에서 각 노드로의 최단 경로는 다음과 같습니다: 
- 0(자기 자신)
- 1(노드 2, 3로 가는 최단 경로)
- 2(노드 4, 5로 가는 최단 경로)
- 3(노드 6으로 가는 최단 경로)

### 제한사항
- 간선의 가중치는 모두 동일합니다(즉, BFS로 해결 가능).
- 모든 간선은 양방향입니다.
- 노드 수 n은 최대 1000개, 간선 수는 최대 10000개입니다.

